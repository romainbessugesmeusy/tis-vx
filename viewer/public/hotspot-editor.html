<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>EPC Diagram Hotspot Editor</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a2e;
      color: #eee;
      min-height: 100vh;
      user-select: none;
    }
    
    .container {
      display: grid;
      grid-template-columns: 320px 1fr;
      height: 100vh;
    }
    
    /* Sidebar */
    .sidebar {
      background: #16213e;
      padding: 16px;
      overflow-y: auto;
      border-right: 1px solid #0f3460;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .sidebar h1 {
      font-size: 1.1rem;
      color: #e94560;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .connection-status {
      font-size: 0.65rem;
      padding: 2px 8px;
      border-radius: 10px;
      background: #dc2626;
    }
    
    .connection-status.connected { background: #16a34a; }
    
    .diagram-search {
      width: 100%;
      padding: 10px 12px;
      background: #0f3460;
      border: 1px solid #333;
      color: #eee;
      border-radius: 6px;
      font-size: 0.9rem;
    }
    
    .diagram-search:focus { outline: none; border-color: #e94560; }
    
    .filter-row {
      display: flex;
      gap: 6px;
    }
    
    .filter-btn {
      flex: 1;
      padding: 6px;
      background: #0f3460;
      border: 1px solid transparent;
      color: #888;
      border-radius: 4px;
      font-size: 0.75rem;
      cursor: pointer;
    }
    
    .filter-btn:hover { background: #1a3a6e; }
    .filter-btn.active { border-color: #e94560; color: #eee; }
    
    .diagram-list {
      flex: 1;
      overflow-y: auto;
      margin: 0 -16px;
      padding: 0 16px;
      min-height: 120px;
      max-height: 200px;
    }
    
    .diagram-item {
      padding: 8px 10px;
      background: #0f3460;
      border-radius: 6px;
      margin-bottom: 4px;
      cursor: pointer;
      transition: all 0.15s;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.85rem;
    }
    
    .diagram-item:hover { background: #1a3a6e; }
    .diagram-item.selected { background: #e94560; }
    
    .diagram-item .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #666;
      flex-shrink: 0;
    }
    
    .diagram-item .status-dot.todo { background: #f59e0b; }
    .diagram-item .status-dot.done { background: #16a34a; }
    
    .diagram-item .sheet-code {
      font-weight: bold;
      min-width: 45px;
    }
    
    .diagram-item .hotspot-count {
      font-size: 0.7rem;
      color: #888;
      margin-left: auto;
    }
    
    .diagram-item.selected .hotspot-count { color: rgba(255,255,255,0.7); }
    
    .info-panel {
      background: #0f3460;
      padding: 12px;
      border-radius: 8px;
    }
    
    .info-panel h3 {
      font-size: 0.8rem;
      color: #888;
      margin-bottom: 6px;
    }
    
    .info-panel .value {
      font-size: 1rem;
      color: #e94560;
    }
    
    .info-panel input.diagram-name {
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.15);
      color: #e94560;
      font-size: 1rem;
      font-weight: bold;
      width: 100%;
      padding: 4px 8px;
      border-radius: 4px;
      box-sizing: border-box;
      outline: none;
    }
    .info-panel input.diagram-name:focus {
      border-color: #e94560;
      background: rgba(255,255,255,0.12);
    }
    .info-panel input.diagram-name::placeholder {
      color: #555;
      font-weight: normal;
    }
    .diagram-uuid {
      font-size: 0.65rem;
      color: #555;
      font-family: monospace;
      margin-top: 3px;
    }
    
    .info-panel .stats {
      font-size: 0.7rem;
      color: #666;
      margin-top: 6px;
    }
    
    .status-toggle {
      display: flex;
      gap: 6px;
      margin-top: 10px;
    }
    
    .status-toggle .status-btn {
      flex: 1;
      padding: 8px;
      border: 1px solid #333;
      border-radius: 4px;
      background: #1a1a2e;
      color: #888;
      font-size: 0.8rem;
      cursor: pointer;
    }
    
    .status-toggle .status-btn:hover { background: #0f3460; }
    .status-toggle .status-btn.active.todo { border-color: #f59e0b; color: #f59e0b; }
    .status-toggle .status-btn.active.done { border-color: #16a34a; color: #16a34a; }
    
    .edit-panel {
      background: #0f3460;
      padding: 12px;
      border-radius: 8px;
      display: none;
    }
    
    .edit-panel.visible { display: block; }
    
    .edit-panel h3 {
      font-size: 0.8rem;
      color: #888;
      margin-bottom: 8px;
    }
    
    .edit-panel .field {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
    }
    
    .edit-panel label {
      font-size: 0.75rem;
      color: #888;
      min-width: 50px;
    }
    
    .edit-panel input {
      flex: 1;
      padding: 5px 8px;
      background: #1a1a2e;
      border: 1px solid #333;
      color: #eee;
      border-radius: 4px;
      font-size: 0.85rem;
    }
    
    .edit-panel input:focus { outline: none; border-color: #e94560; }
    
    .edit-panel .btn-row {
      display: flex;
      gap: 6px;
      margin-top: 8px;
    }
    
    .hotspots-list {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }
    
    .hotspots-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }
    
    .hotspots-list h2 {
      font-size: 0.85rem;
      color: #888;
    }
    
    .save-status {
      font-size: 0.7rem;
      margin-left: auto;
      transition: opacity 0.3s;
    }
    .save-status.saving { color: #f59e0b; }
    .save-status.saved { color: #16a34a; }
    .save-status.error { color: #ef4444; }
    .save-status.idle { opacity: 0; }
    
    .clear-all-btn {
      background: none;
      border: 1px solid #333;
      color: #666;
      width: 22px;
      height: 22px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.7rem;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }
    .clear-all-btn:hover:not(:disabled) { border-color: #e94560; color: #e94560; }
    .clear-all-btn:disabled { opacity: 0.3; cursor: not-allowed; }
    
    .hotspots-scroll {
      flex: 1;
      overflow-y: auto;
      margin: 0 -16px;
      padding: 0 16px;
    }
    
    .hotspot-item {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      background: #0f3460;
      border-radius: 6px;
      margin-bottom: 4px;
      cursor: pointer;
      transition: all 0.15s;
      font-size: 0.85rem;
    }
    
    .hotspot-item:hover { background: #1a3a6e; }
    .hotspot-item.selected { background: #e94560; }
    .hotspot-item.highlighted { background: #f59e0b; }
    
    .hotspot-item .ref { font-weight: bold; min-width: 28px; }
    .hotspot-item .type { font-size: 0.65rem; color: #666; }
    .hotspot-item .delete-btn {
      background: none;
      border: none;
      color: #e94560;
      cursor: pointer;
      font-size: 1.1rem;
      opacity: 0.5;
      padding: 0 4px;
      margin-left: auto;
    }
    .hotspot-item .delete-btn:hover { opacity: 1; }
    
    /* (actions bar removed - autosave) */
    
    .btn {
      padding: 10px 16px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.85rem;
      font-weight: 500;
      transition: all 0.15s;
    }
    
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .btn-primary { background: #e94560; color: white; }
    .btn-primary:hover:not(:disabled) { background: #ff6b6b; }
    .btn-secondary { background: #0f3460; color: #eee; border: 1px solid #333; }
    .btn-secondary:hover:not(:disabled) { background: #1a3a6e; }
    .btn-success { background: #16a34a; color: white; }
    .btn-small { padding: 5px 10px; font-size: 0.75rem; }
    
    /* (unsaved indicator removed - replaced by save status) */
    
    .keyboard-hints {
      font-size: 0.65rem;
      color: #555;
      padding: 8px;
      background: rgba(0,0,0,0.2);
      border-radius: 6px;
      line-height: 1.7;
    }
    
    .keyboard-hints kbd {
      background: #333;
      padding: 1px 5px;
      border-radius: 3px;
      font-family: monospace;
    }
    
    /* Main Area */
    .main-area {
      padding: 16px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      background: #12121f;
    }
    
    .toolbar {
      display: flex;
      gap: 6px;
      margin-bottom: 12px;
      padding: 8px 12px;
      background: #16213e;
      border-radius: 8px;
      align-items: center;
      flex-wrap: wrap;
    }
    
    .toolbar .mode {
      padding: 6px 12px;
      background: #0f3460;
      border: 1px solid transparent;
      color: #eee;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.15s;
      font-size: 0.8rem;
    }
    
    .toolbar .mode:hover { background: #1a3a6e; }
    .toolbar .mode.active { border-color: #e94560; background: #e94560; }
    
    .toolbar .separator {
      width: 1px;
      height: 20px;
      background: #333;
      margin: 0 6px;
    }
    
    .toolbar input {
      padding: 6px 10px;
      background: #0f3460;
      border: 1px solid #333;
      color: #eee;
      border-radius: 4px;
      width: 70px;
      font-size: 0.8rem;
    }
    
    .toolbar input:focus { outline: none; border-color: #4ecdc4; }
    
    .toolbar label {
      font-size: 0.8rem;
      color: #888;
    }
    
    .toolbar .hint {
      font-size: 0.7rem;
      color: #666;
      margin-left: auto;
    }
    
    .zoom-controls {
      display: flex;
      align-items: center;
      gap: 4px;
      margin-left: 8px;
    }
    
    .zoom-controls button {
      width: 28px;
      height: 28px;
      background: #0f3460;
      border: 1px solid #333;
      color: #eee;
      border-radius: 4px;
      cursor: pointer;
      font-size: 1rem;
    }
    
    .zoom-controls button:hover { background: #1a3a6e; }
    
    .zoom-controls .zoom-level {
      font-size: 0.75rem;
      color: #888;
      min-width: 45px;
      text-align: center;
    }
    
    .viewport {
      flex: 1;
      overflow: auto;
      background: #0a0a12;
      border-radius: 8px;
      position: relative;
    }
    
    .diagram-container {
      position: relative;
      transform-origin: 0 0;
      background: white;
      display: inline-block;
      --inv-zoom: 1;
    }
    
    .diagram-container img {
      display: block;
      pointer-events: none;
    }
    
    .diagram-container.drawing { cursor: crosshair; }
    .diagram-container.polygon { cursor: crosshair; }
    .diagram-container.lasso { cursor: crosshair; }
    .diagram-container.wand { cursor: crosshair; }
    .diagram-container.moving { cursor: move; }
    .diagram-container.panning { cursor: grab; }
    .diagram-container.panning:active { cursor: grabbing; }
    
    /* Hotspot overlays */
    .hotspot-overlay {
      position: absolute;
      cursor: move;
      transition: opacity 0.15s;
    }
    
    /* Hide hotspots when actively drawing */
    .diagram-container.hide-hotspots .hotspot-overlay {
      opacity: 0.15;
      pointer-events: none;
    }
    
    .hotspot-overlay.rect {
      border: calc(2px * var(--inv-zoom, 1)) solid #3b82f6;
      background: rgba(59, 130, 246, 0.15);
      border-radius: 3px;
    }
    
    .hotspot-overlay.polygon {
      pointer-events: none;
    }
    
    .hotspot-overlay.polygon svg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    
    .hotspot-overlay.polygon polygon {
      fill: rgba(139, 92, 246, 0.2);
      stroke: #8b5cf6;
      stroke-width: calc(2 * var(--inv-zoom, 1));
      pointer-events: auto;
      cursor: move;
    }
    
    .hotspot-overlay:hover .rect-bg,
    .hotspot-overlay.rect:hover {
      border-color: #60a5fa;
      background: rgba(59, 130, 246, 0.25);
    }
    
    .hotspot-overlay.polygon:hover polygon {
      fill: rgba(139, 92, 246, 0.35);
    }
    
    .hotspot-overlay.selected.rect {
      border-color: #e94560;
      background: rgba(233, 69, 96, 0.3);
      z-index: 10;
    }
    
    .hotspot-overlay.selected.polygon polygon {
      fill: rgba(233, 69, 96, 0.3);
      stroke: #e94560;
    }
    
    .hotspot-overlay.highlighted.rect {
      border-color: #f59e0b;
      background: rgba(245, 158, 11, 0.3);
    }
    
    .hotspot-overlay.highlighted.polygon polygon {
      fill: rgba(245, 158, 11, 0.3);
      stroke: #f59e0b;
    }
    
    .hotspot-overlay .label {
      position: absolute;
      top: -20px;
      left: 50%;
      transform: translateX(-50%) scale(var(--inv-zoom, 1));
      transform-origin: bottom center;
      background: #3b82f6;
      color: white;
      padding: 1px 5px;
      border-radius: 3px;
      font-size: 10px;
      font-weight: bold;
      white-space: nowrap;
      pointer-events: none;
    }
    
    .hotspot-overlay.polygon .label { background: #8b5cf6; }
    .hotspot-overlay.selected .label { background: #e94560; }
    .hotspot-overlay.highlighted .label { background: #f59e0b; }
    
    .resize-handle {
      position: absolute;
      width: 10px;
      height: 10px;
      background: #e94560;
      border: 1px solid white;
      border-radius: 2px;
      display: none;
      transform: scale(var(--inv-zoom, 1));
    }
    
    .hotspot-overlay.selected .resize-handle { display: block; }
    
    .resize-handle.nw { top: -5px; left: -5px; cursor: nw-resize; }
    .resize-handle.ne { top: -5px; right: -5px; cursor: ne-resize; }
    .resize-handle.sw { bottom: -5px; left: -5px; cursor: sw-resize; }
    .resize-handle.se { bottom: -5px; right: -5px; cursor: se-resize; }
    
    /* Vertex layer - sits on top of SVG */
    .vertex-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 100;
      pointer-events: none; /* Layer itself doesn't capture */
    }
    
    /* Polygon vertex handles - must be above SVG edges */
    .vertex-handle {
      position: absolute;
      width: 18px;
      height: 18px;
      background: #8b5cf6;
      border: 2px solid white;
      border-radius: 50%;
      transform: translate(-50%, -50%) scale(var(--inv-zoom, 1));
      cursor: move;
      pointer-events: auto; /* But handles do capture */
      box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.3);
    }
    
    .vertex-handle:hover {
      background: #ef4444;
      transform: translate(-50%, -50%) scale(calc(var(--inv-zoom, 1) * 1.2));
      box-shadow: 0 0 0 4px rgba(239, 68, 68, 0.3);
    }
    
    /* Edge segments for adding points - avoid vertex areas */
    .edge-segment {
      stroke: transparent;
      stroke-width: calc(10 * var(--inv-zoom, 1));
      cursor: copy;
      pointer-events: stroke;
    }
    
    .edge-segment:hover {
      stroke: rgba(139, 92, 246, 0.4);
    }
    
    /* SVG must not block vertex handles */
    .hotspot-overlay.polygon svg {
      overflow: visible;
    }
    
    .sheet-code-overlay {
      position: absolute;
      border: 2px solid #4ecdc4;
      background: rgba(78, 205, 196, 0.2);
      pointer-events: none;
    }
    
    .sheet-code-overlay .label {
      position: absolute;
      top: -18px;
      left: 0;
      background: #4ecdc4;
      color: #1a1a2e;
      padding: 1px 5px;
      border-radius: 3px;
      font-size: 10px;
      font-weight: bold;
    }
    
    .draw-preview {
      position: absolute;
      border: calc(2px * var(--inv-zoom, 1)) dashed #4ecdc4;
      background: rgba(78, 205, 196, 0.2);
      pointer-events: none;
      display: none;
    }
    
    .draw-preview.visible { display: block; }
    
    /* Polygon drawing preview */
    .polygon-preview {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    
    /* Isometric/diamond drawing preview */
    .isometric-preview {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    
    .isometric-preview polygon {
      fill: rgba(255, 183, 77, 0.2);
      stroke: #ffb74d;
      stroke-width: calc(2 * var(--inv-zoom, 1));
      stroke-dasharray: 5, 3;
    }
    
    .polygon-preview polyline {
      fill: none;
      stroke: #4ecdc4;
      stroke-width: calc(2 * var(--inv-zoom, 1));
      stroke-dasharray: 5, 5;
    }
    
    .polygon-preview.lasso-mode polyline {
      stroke: #f472b6;
      stroke-dasharray: none;
    }
    
    .polygon-preview.lasso-mode .close-line {
      stroke: #f472b6;
      stroke-width: calc(1 * var(--inv-zoom, 1));
      stroke-dasharray: 3, 3;
      opacity: 0.5;
    }
    
    .polygon-preview .temp-line {
      stroke: #4ecdc4;
      stroke-width: calc(1 * var(--inv-zoom, 1));
      stroke-dasharray: 3, 3;
      opacity: 0.5;
    }
    
    .polygon-preview circle {
      fill: #4ecdc4;
      stroke: white;
      stroke-width: calc(2 * var(--inv-zoom, 1));
      r: calc(5 * var(--inv-zoom, 1));
    }
    
    .polygon-preview circle.close-hint {
      fill: #16a34a;
      r: calc(8 * var(--inv-zoom, 1));
    }
    
    /* Dialog */
    .overlay-bg {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      z-index: 999;
      display: none;
    }
    
    .overlay-bg.visible { display: block; }
    
    .dialog {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #16213e;
      padding: 24px;
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
      z-index: 1000;
      display: none;
      min-width: 260px;
    }
    
    .dialog.visible { display: block; }
    
    .dialog h3 { margin-bottom: 16px; color: #e94560; font-size: 1rem; }
    
    .dialog input {
      width: 100%;
      padding: 10px;
      background: #0f3460;
      border: 1px solid #e94560;
      color: #eee;
      border-radius: 6px;
      font-size: 1rem;
      margin-bottom: 12px;
    }
    
    .dialog input:focus { outline: none; border-color: #ff6b6b; }
    
    .dialog .buttons { display: flex; gap: 8px; }
    .dialog .buttons .btn { flex: 1; }
    
    /* Toast */
    .toast {
      position: fixed;
      bottom: 20px;
      right: 20px;
      padding: 12px 20px;
      background: #4ecdc4;
      color: #1a1a2e;
      border-radius: 8px;
      font-weight: 500;
      font-size: 0.9rem;
      transform: translateY(100px);
      opacity: 0;
      transition: all 0.3s;
      z-index: 2000;
    }
    
    .toast.visible { transform: translateY(0); opacity: 1; }
    .toast.error { background: #dc2626; color: white; }
    .toast.success { background: #16a34a; color: white; }
    
    .empty-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: #666;
      text-align: center;
      padding: 40px;
    }
    
    .empty-state .icon { font-size: 3rem; margin-bottom: 16px; opacity: 0.5; }
  </style>
</head>
<body>
  <div class="container">
    <div class="sidebar">
      <h1>
        üîß Hotspot Editor
        <span class="connection-status" id="connectionStatus">offline</span>
      </h1>
      
      <input type="text" class="diagram-search" id="diagramSearch" placeholder="Search diagrams...">
      
      <div class="filter-row">
        <button class="filter-btn active" data-filter="all">All</button>
        <button class="filter-btn" data-filter="todo">‚è≥ To-Do</button>
        <button class="filter-btn" data-filter="done">‚úÖ Done</button>
      </div>
      
      <div class="diagram-list" id="diagramList">
        <div class="empty-state">
          <div class="icon">üì°</div>
          <p>Connecting...</p>
        </div>
      </div>
      
      <div class="info-panel" id="infoPanel" style="display: none;">
        <h3>Current Diagram</h3>
        <input type="text" class="diagram-name" id="currentDiagramInput" placeholder="Sheet code (e.g. F4)">
        <div class="diagram-uuid" id="diagramUuid">‚Äî</div>
        <div class="stats">
          <span id="imageSize">‚Äî</span> ‚Ä¢ <span id="hotspotCount">0</span> hotspots
        </div>
        <div class="status-toggle">
          <button class="status-btn todo" data-status="todo">‚è≥ To-Do</button>
          <button class="status-btn done" data-status="done">‚úÖ Done</button>
        </div>
      </div>
      
      <div class="edit-panel" id="editPanel">
        <h3>Edit Hotspot</h3>
        <div class="field">
          <label>Ref #</label>
          <input type="number" id="editRef" min="1" max="99">
        </div>
        <div class="btn-row">
          <button class="btn btn-primary btn-small" id="applyEditBtn">Apply</button>
          <button class="btn btn-secondary btn-small" id="deleteSelectedBtn">Delete</button>
        </div>
      </div>
      
      <div class="hotspots-list" id="hotspotsPanel" style="display: none;">
        <div class="hotspots-header">
          <h2>Hotspots</h2>
          <span id="saveStatus" class="save-status idle"></span>
          <button class="clear-all-btn" id="clearAllBtn" disabled title="Clear all hotspots">‚úï</button>
        </div>
        <div class="hotspots-scroll" id="hotspotsList"></div>
      </div>
      
      <div class="keyboard-hints">
        <kbd>V</kbd> Select ‚Ä¢ <kbd>R</kbd> Rect ‚Ä¢ <kbd>I</kbd> Iso ‚Ä¢ <kbd>L</kbd> Poly ‚Ä¢ <kbd>O</kbd> Lasso ‚Ä¢ <kbd>W</kbd> Wand<br>
        <kbd>Del</kbd> Delete ‚Ä¢ <kbd>Ctrl+D</kbd> Duplicate ‚Ä¢ <kbd>Esc</kbd> Cancel<br>
        <em>Double-click</em> hotspot to edit ref #
      </div>
    </div>
    
    <div class="main-area">
      <div class="toolbar" id="toolbar" style="display: none;">
        <button class="mode" data-mode="select" title="Select tool (V)">üñ±Ô∏è Select</button>
        <button class="mode active" data-mode="draw" title="Rectangle tool (R)">‚ñ¢ Rect</button>
        <button class="mode" data-mode="isometric" title="Isometric/Diamond tool (I)">‚óá Iso</button>
        <button class="mode" data-mode="polygon" title="Polygon tool (L)">‚¨° Poly</button>
        <button class="mode" data-mode="lasso" title="Lasso tool (O)">‚ó† Lasso</button>
        <button class="mode" data-mode="wand" title="Magic Wand (W)">ü™Ñ Wand</button>
        <div class="separator"></div>
        <div class="zoom-controls">
          <button id="zoomOut">‚àí</button>
          <span class="zoom-level" id="zoomLevel">100%</span>
          <button id="zoomIn">+</button>
          <button id="zoomFit" title="Fit to view">‚ä°</button>
        </div>
        <span class="hint" id="modeHint">Click and drag to draw</span>
      </div>
      
      <div class="viewport" id="viewport">
        <div class="diagram-container" id="diagramContainer" style="display: none;">
          <img id="diagramImage" src="" alt="Diagram" draggable="false">
          <div id="overlays"></div>
          <div class="draw-preview" id="drawPreview"></div>
          <svg class="isometric-preview" id="isometricPreview" style="display: none;">
            <polygon id="isometricShape" points=""></polygon>
          </svg>
          <svg class="polygon-preview" id="polygonPreview" style="display: none;">
            <polyline id="polygonLines" points=""></polyline>
            <line id="tempLine" class="temp-line" x1="0" y1="0" x2="0" y2="0"></line>
            <line id="closeLine" class="close-line" x1="0" y1="0" x2="0" y2="0" style="display: none;"></line>
          </svg>
        </div>
        
        <div class="empty-state" id="emptyState">
          <div class="icon">üñºÔ∏è</div>
          <p>Select a diagram to edit</p>
        </div>
      </div>
    </div>
  </div>
  
  <div class="overlay-bg" id="overlayBg"></div>
  <div class="dialog" id="refDialog">
    <h3>Part Reference Number</h3>
    <input type="number" id="refInput" placeholder="1-99" min="1" max="99">
    <div class="buttons">
      <button class="btn btn-primary" id="confirmRefBtn">Add</button>
      <button class="btn btn-secondary" id="cancelRefBtn">Cancel</button>
    </div>
  </div>
  
  <div class="toast" id="toast"></div>

  <script>
    const API_BASE = 'http://localhost:3001/api';
    
    // State
    let diagrams = [];
    let currentData = null;
    let currentDiagramId = null;
    let currentMode = 'draw';
    let currentFilter = 'all';
    let hasUnsavedChanges = false;
    let isConnected = false;
    
    // Interaction
    let selectedIndex = null;
    let isDrawing = false;
    let isMoving = false;
    let isResizing = false;
    let isPanning = false;
    let spacePressed = false;
    let resizeHandle = null;
    let vertexIndex = null;
    let vertexClickStart = null; // Track if vertex was clicked (for click-to-delete)
    let drawStart = null;
    let moveStart = null;
    let panStart = null;
    let originalBbox = null;
    let originalPoints = null;
    
    // Polygon drawing
    let polygonPoints = [];
    let tempMousePos = null;
    
    // Lasso drawing
    let isLassoDrawing = false;
    const LASSO_MIN_DISTANCE = 5; // Minimum pixels between captured points
    
    // Magic Wand
    let wandCanvas = null;
    let wandCtx = null;
    let wandImageData = null;
    const WAND_THRESHOLD = 80;      // Brightness below this = "dark" (low = ignore antialiased gray)
    const WAND_EXPAND = 4;          // Pixels to expand contour outward
    const WAND_MAX_PIXELS = 200000; // Flood fill safety limit
    const WAND_MIN_PIXELS = 10;     // Minimum region size
    const WAND_BUCKETS = 72;        // Angular resolution (5¬∞ per bucket)
    const WAND_SNAP_RADIUS = 8;     // Snap-to-contour search radius
    
    // Zoom
    let zoom = 1;
    const MIN_ZOOM = 0.25;
    const MAX_ZOOM = 4;
    
    // Elements
    const viewport = document.getElementById('viewport');
    const diagramContainer = document.getElementById('diagramContainer');
    const diagramImage = document.getElementById('diagramImage');
    const drawPreview = document.getElementById('drawPreview');
    const isometricPreview = document.getElementById('isometricPreview');
    const isometricShape = document.getElementById('isometricShape');
    const polygonPreview = document.getElementById('polygonPreview');
    const polygonLines = document.getElementById('polygonLines');
    const tempLine = document.getElementById('tempLine');
    const closeLine = document.getElementById('closeLine');
    
    // Connection
    async function checkConnection() {
      try {
        const res = await fetch(`${API_BASE}/diagrams`);
        if (res.ok) {
          isConnected = true;
          document.getElementById('connectionStatus').textContent = 'online';
          document.getElementById('connectionStatus').classList.add('connected');
          return true;
        }
      } catch (e) {}
      isConnected = false;
      document.getElementById('connectionStatus').textContent = 'offline';
      document.getElementById('connectionStatus').classList.remove('connected');
      return false;
    }
    
    // Load diagrams
    async function loadDiagramList() {
      const connected = await checkConnection();
      if (!connected) {
        document.getElementById('diagramList').innerHTML = `
          <div class="empty-state">
            <div class="icon">‚ö†Ô∏è</div>
            <p style="font-size: 0.8rem;">Run: node hotspot-server.js</p>
          </div>
        `;
        return;
      }
      
      try {
        const response = await fetch(`${API_BASE}/diagrams`);
        const data = await response.json();
        diagrams = data.diagrams;
        renderDiagramList();
      } catch (e) {
        showToast('Failed to load diagrams', 'error');
      }
    }
    
    function renderDiagramList() {
      const list = document.getElementById('diagramList');
      const search = document.getElementById('diagramSearch').value.toLowerCase();
      
      let filtered = diagrams.filter(d => {
        const matchesSearch = !search || 
          d.sheetCode?.toLowerCase().includes(search) ||
          d.id.toLowerCase().includes(search);
        const matchesFilter = currentFilter === 'all' ||
          (currentFilter === 'done' && d.status === 'done') ||
          (currentFilter === 'todo' && d.status !== 'done');
        return matchesSearch && matchesFilter;
      });
      
      if (filtered.length === 0) {
        list.innerHTML = `<div class="empty-state"><p style="font-size:0.8rem">No diagrams</p></div>`;
        return;
      }
      
      list.innerHTML = filtered.map(d => `
        <div class="diagram-item ${d.id === currentDiagramId ? 'selected' : ''}" data-id="${d.id}">
          <span class="status-dot ${d.status || 'todo'}"></span>
          <span class="sheet-code">${d.sheetCode || '‚Äî'}</span>
          <span class="hotspot-count">${d.hotspotCount}</span>
        </div>
      `).join('');
      
      list.querySelectorAll('.diagram-item').forEach(item => {
        item.addEventListener('click', async () => {
          // Autosave current diagram before switching
          if (hasUnsavedChanges) await saveChanges();
          loadDiagram(item.dataset.id);
        });
      });
    }
    
    // Load diagram
    async function loadDiagram(diagramId) {
      if (!isConnected) return;
      
      currentDiagramId = diagramId;
      selectedIndex = null;
      polygonPoints = [];
      wandImageData = null; // Clear wand cache for new diagram
      diagramContainer.classList.remove('hide-hotspots');
      
      try {
        const response = await fetch(`${API_BASE}/hotspots/${diagramId}`);
        currentData = await response.json();
        if (!currentData.hotspots) currentData.hotspots = [];
        if (!currentData.status) currentData.status = 'todo';
        
        diagramImage.src = `/data/epc/diagrams/${diagramId}.png`;
        
        await new Promise((resolve, reject) => {
          diagramImage.onload = () => {
            if (!currentData.imageWidth) {
              currentData.imageWidth = diagramImage.naturalWidth;
              currentData.imageHeight = diagramImage.naturalHeight;
            }
            resolve();
          };
          diagramImage.onerror = reject;
        });
        
        document.getElementById('emptyState').style.display = 'none';
        diagramContainer.style.display = 'block';
        document.getElementById('toolbar').style.display = 'flex';
        document.getElementById('infoPanel').style.display = 'block';
        document.getElementById('hotspotsPanel').style.display = 'flex';
        
        document.getElementById('currentDiagramInput').value = currentData.sheetCode?.text || '';
        document.getElementById('diagramUuid').textContent = diagramId;
        document.getElementById('imageSize').textContent = `${currentData.imageWidth}√ó${currentData.imageHeight}`;
        
        
        updateStatusButtons();
        
        hasUnsavedChanges = false;
        updateSaveStatus('idle');
        updateUI();
        fitToView();
        
        document.getElementById('clearAllBtn').disabled = false;
        
      } catch (e) {
        showToast('Failed to load diagram', 'error');
      }
    }
    
    // Zoom
    function setZoom(newZoom, centerX, centerY) {
      const oldZoom = zoom;
      zoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newZoom));
      
      diagramContainer.style.transform = `scale(${zoom})`;
      diagramContainer.style.setProperty('--inv-zoom', 1 / zoom);
      document.getElementById('zoomLevel').textContent = `${Math.round(zoom * 100)}%`;
      
      // Adjust scroll to zoom towards center point
      if (centerX !== undefined && centerY !== undefined) {
        const rect = viewport.getBoundingClientRect();
        const scrollX = (centerX - rect.left + viewport.scrollLeft) * (zoom / oldZoom) - (centerX - rect.left);
        const scrollY = (centerY - rect.top + viewport.scrollTop) * (zoom / oldZoom) - (centerY - rect.top);
        viewport.scrollLeft = scrollX;
        viewport.scrollTop = scrollY;
      }
    }
    
    function fitToView() {
      if (!currentData) return;
      const vw = viewport.clientWidth - 40;
      const vh = viewport.clientHeight - 40;
      const iw = currentData.imageWidth;
      const ih = currentData.imageHeight;
      const fitZoom = Math.min(vw / iw, vh / ih, 1);
      setZoom(fitZoom);
      viewport.scrollLeft = 0;
      viewport.scrollTop = 0;
    }
    
    // Render
    function updateUI() {
      updateSaveStatus(hasUnsavedChanges ? 'unsaved' : 'idle');
      updateEditPanel();
      renderDiagramList();
      renderHotspots();
      renderHotspotList();
    }
    
    let saveStatusFadeTimer = null;
    function updateSaveStatus(status) {
      const el = document.getElementById('saveStatus');
      if (!el) return;
      if (saveStatusFadeTimer) { clearTimeout(saveStatusFadeTimer); saveStatusFadeTimer = null; }
      el.className = 'save-status ' + status;
      if (status === 'saving') el.textContent = 'Saving...';
      else if (status === 'saved') {
        el.textContent = 'Saved';
        saveStatusFadeTimer = setTimeout(() => { el.className = 'save-status idle'; el.textContent = ''; }, 2000);
      }
      else if (status === 'error') el.textContent = 'Save failed';
      else if (status === 'unsaved') el.textContent = '';
      else { el.className = 'save-status idle'; el.textContent = ''; }
    }
    
    function updateStatusButtons() {
      document.querySelectorAll('.status-toggle .status-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.status === currentData?.status);
      });
    }
    
    function updateEditPanel() {
      const panel = document.getElementById('editPanel');
      if (selectedIndex === null || !currentData?.hotspots[selectedIndex]) {
        panel.classList.remove('visible');
        return;
      }
      const h = currentData.hotspots[selectedIndex];
      panel.classList.add('visible');
      document.getElementById('editRef').value = h.ref;
    }
    
    function renderHotspots() {
      const container = document.getElementById('overlays');
      container.innerHTML = '';
      if (!currentData) return;
      
      // Sheet code
      if (currentData.sheetCode?.bbox) {
        const sc = currentData.sheetCode;
        const div = document.createElement('div');
        div.className = 'sheet-code-overlay';
        div.style.cssText = `left:${sc.bbox.x}px;top:${sc.bbox.y}px;width:${sc.bbox.width}px;height:${sc.bbox.height}px;`;
        div.innerHTML = `<span class="label">Sheet: ${sc.text}</span>`;
        container.appendChild(div);
      }
      
      // Hotspots
      currentData.hotspots.forEach((h, index) => {
        const isSelected = index === selectedIndex;
        const div = document.createElement('div');
        
        if (h.type === 'polygon' && h.points) {
          // Polygon hotspot
          const bounds = getPolygonBounds(h.points);
          div.className = `hotspot-overlay polygon ${isSelected ? 'selected' : ''}`;
          div.dataset.index = index;
          div.style.cssText = `left:${bounds.x}px;top:${bounds.y}px;width:${bounds.width}px;height:${bounds.height}px;`;
          
          // Create SVG polygon with edge segments
          const localPoints = h.points.map(p => `${p.x - bounds.x},${p.y - bounds.y}`).join(' ');
          
          // Create edge lines for click-to-add-point
          let edgeLines = '';
          if (isSelected) {
            for (let ei = 0; ei < h.points.length; ei++) {
              const p1 = h.points[ei];
              const p2 = h.points[(ei + 1) % h.points.length];
              edgeLines += `<line class="edge-segment" data-edge="${ei}" 
                x1="${p1.x - bounds.x}" y1="${p1.y - bounds.y}" 
                x2="${p2.x - bounds.x}" y2="${p2.y - bounds.y}"/>`;
            }
          }
          
          div.innerHTML = `
            <span class="label">${h.ref}</span>
            <svg viewBox="0 0 ${bounds.width} ${bounds.height}">
              <polygon points="${localPoints}" data-index="${index}"></polygon>
              ${edgeLines}
            </svg>
            ${isSelected ? `<div class="vertex-layer">${h.points.map((p, vi) => 
              `<div class="vertex-handle" data-vertex="${vi}" style="left:${p.x - bounds.x}px;top:${p.y - bounds.y}px;" title="Drag to move ‚Ä¢ Click to delete"></div>`
            ).join('')}</div>` : ''}
          `;
          
          // Events on polygon
          div.querySelector('polygon').addEventListener('mousedown', (e) => handleHotspotMouseDown(e, index));
          div.querySelector('polygon').addEventListener('dblclick', (e) => {
            e.stopPropagation();
            showEditRefDialog(index);
          });
          
          // Edge click to add point
          div.querySelectorAll('.edge-segment').forEach(edge => {
            edge.addEventListener('click', (e) => {
              e.stopPropagation();
              const edgeIdx = parseInt(edge.dataset.edge);
              const svgEl = div.querySelector('svg');
              const svgRect = svgEl.getBoundingClientRect();
              // Convert screen coordinates to SVG/image coordinates
              // viewBox is in image pixels, display size is affected by zoom
              const scaleX = bounds.width / svgRect.width;
              const scaleY = bounds.height / svgRect.height;
              const newPoint = {
                x: bounds.x + (e.clientX - svgRect.left) * scaleX,
                y: bounds.y + (e.clientY - svgRect.top) * scaleY
              };
              // Insert after edgeIdx
              h.points.splice(edgeIdx + 1, 0, newPoint);
              markUnsaved();
              renderHotspots();
            });
          });
          
          // Vertex drag and click-to-delete
          div.querySelectorAll('.vertex-handle').forEach(vh => {
            vh.addEventListener('mousedown', (e) => {
              e.stopPropagation();
              vertexIndex = parseInt(vh.dataset.vertex);
              selectedIndex = index;
              originalPoints = h.points.map(p => ({...p}));
              moveStart = { x: e.clientX, y: e.clientY };
              vertexClickStart = { x: e.clientX, y: e.clientY, hotspotIndex: index };
              // Don't call updateUI() here - it destroys the element mid-interaction
            });
          });
          
        } else {
          // Rectangle hotspot
          div.className = `hotspot-overlay rect ${isSelected ? 'selected' : ''}`;
          div.dataset.index = index;
          div.style.cssText = `left:${h.bbox.x}px;top:${h.bbox.y}px;width:${h.bbox.width}px;height:${h.bbox.height}px;`;
          div.innerHTML = `
            <span class="label">${h.ref}</span>
            <div class="resize-handle nw" data-handle="nw"></div>
            <div class="resize-handle ne" data-handle="ne"></div>
            <div class="resize-handle sw" data-handle="sw"></div>
            <div class="resize-handle se" data-handle="se"></div>
          `;
          
          div.addEventListener('mousedown', (e) => handleHotspotMouseDown(e, index));
          div.addEventListener('dblclick', (e) => {
            e.stopPropagation();
            showEditRefDialog(index);
          });
        }
        
        container.appendChild(div);
      });
    }
    
    function handleHotspotMouseDown(e, index) {
      if (currentMode !== 'select') return;
      e.stopPropagation();
      
      const handle = e.target.dataset?.handle;
      if (handle) {
        isResizing = true;
        resizeHandle = handle;
        selectedIndex = index;
        originalBbox = { ...currentData.hotspots[index].bbox };
        moveStart = { x: e.clientX, y: e.clientY };
      } else {
        selectHotspot(index);
        isMoving = true;
        const h = currentData.hotspots[index];
        if (h.type === 'polygon') {
          originalPoints = h.points.map(p => ({...p}));
        } else {
          originalBbox = { ...h.bbox };
        }
        moveStart = { x: e.clientX, y: e.clientY };
        diagramContainer.classList.add('moving');
      }
    }
    
    function getPolygonBounds(points) {
      const xs = points.map(p => p.x);
      const ys = points.map(p => p.y);
      const x = Math.min(...xs);
      const y = Math.min(...ys);
      return { x, y, width: Math.max(...xs) - x, height: Math.max(...ys) - y };
    }
    
    function renderHotspotList() {
      const list = document.getElementById('hotspotsList');
      document.getElementById('hotspotCount').textContent = currentData?.hotspots.length || 0;
      if (!currentData) { list.innerHTML = ''; return; }
      
      const sorted = [...currentData.hotspots]
        .map((h, i) => ({ ...h, idx: i }))
        .sort((a, b) => a.ref - b.ref);
      
      list.innerHTML = sorted.map(h => `
        <div class="hotspot-item ${h.idx === selectedIndex ? 'selected' : ''}" data-index="${h.idx}">
          <span class="ref">#${h.ref}</span>
          <span class="type">${h.type === 'polygon' ? '‚¨°' : '‚ñ¢'}</span>
          <button class="delete-btn">√ó</button>
        </div>
      `).join('');
      
      list.querySelectorAll('.hotspot-item').forEach(item => {
        const idx = parseInt(item.dataset.index);
        item.addEventListener('click', (e) => {
          if (e.target.classList.contains('delete-btn')) return;
          selectHotspot(idx);
        });
        item.addEventListener('mouseenter', () => highlightHotspot(idx));
        item.addEventListener('mouseleave', () => highlightHotspot(null));
        item.querySelector('.delete-btn').addEventListener('click', (e) => {
          e.stopPropagation();
          deleteHotspot(idx);
        });
      });
    }
    
    function selectHotspot(index) {
      selectedIndex = index;
      updateUI();
    }
    
    function highlightHotspot(index) {
      document.querySelectorAll('.hotspot-overlay').forEach(el => {
        const i = parseInt(el.dataset.index);
        el.classList.toggle('highlighted', i === index && i !== selectedIndex);
      });
      document.querySelectorAll('.hotspot-item').forEach(el => {
        const i = parseInt(el.dataset.index);
        el.classList.toggle('highlighted', i === index && i !== selectedIndex);
      });
    }
    
    function deleteHotspot(index) {
      currentData.hotspots.splice(index, 1);
      if (selectedIndex === index) selectedIndex = null;
      else if (selectedIndex > index) selectedIndex--;
      markUnsaved();
      updateUI();
    }
    
    function duplicateHotspot(index) {
      const h = currentData.hotspots[index];
      if (!h) return;
      const OFFSET = 15;
      let clone;
      if (h.type === 'polygon' && h.points) {
        clone = {
          type: 'polygon',
          ref: h.ref,
          points: h.points.map(p => ({ x: p.x + OFFSET, y: p.y + OFFSET })),
          confidence: 100,
          manual: true,
        };
      } else {
        clone = {
          type: 'rect',
          ref: h.ref,
          bbox: { x: h.bbox.x + OFFSET, y: h.bbox.y + OFFSET, width: h.bbox.width, height: h.bbox.height },
          normalized: {
            x: (h.bbox.x + OFFSET) / currentData.imageWidth,
            y: (h.bbox.y + OFFSET) / currentData.imageHeight,
            width: h.bbox.width / currentData.imageWidth,
            height: h.bbox.height / currentData.imageHeight,
          },
          confidence: 100,
          manual: true,
        };
      }
      currentData.hotspots.push(clone);
      selectedIndex = currentData.hotspots.length - 1;
      markUnsaved();
      updateUI();
      showToast(`Duplicated #${h.ref}`, 'success');
    }
    
    let autosaveTimer = null;
    let isSaving = false;
    const AUTOSAVE_DELAY = 1500;
    
    function markUnsaved() {
      hasUnsavedChanges = true;
      updateSaveStatus('unsaved');
      
      // Debounce autosave
      if (autosaveTimer) clearTimeout(autosaveTimer);
      autosaveTimer = setTimeout(() => saveChanges(), AUTOSAVE_DELAY);
    }
    
    // Add hotspot
    function addRectHotspot(bbox, ref) {
      const h = {
        type: 'rect',
        ref,
        bbox: { ...bbox },
        normalized: {
          x: bbox.x / currentData.imageWidth,
          y: bbox.y / currentData.imageHeight,
          width: bbox.width / currentData.imageWidth,
          height: bbox.height / currentData.imageHeight,
        },
        confidence: 100,
        manual: true,
      };
      currentData.hotspots.push(h);
      selectedIndex = currentData.hotspots.length - 1;
      markUnsaved();
      updateUI();
      showToast(`Added #${ref}`, 'success');
    }
    
    function addPolygonHotspot(points, ref) {
      const h = {
        type: 'polygon',
        ref,
        points: points.map(p => ({ x: p.x, y: p.y })),
        confidence: 100,
        manual: true,
      };
      currentData.hotspots.push(h);
      selectedIndex = currentData.hotspots.length - 1;
      
      // Clear polygon drawing state
      polygonPoints = [];
      polygonPreview.querySelectorAll('circle').forEach(c => c.remove());
      polygonLines.setAttribute('points', '');
      tempLine.setAttribute('x1', 0);
      tempLine.setAttribute('y1', 0);
      tempLine.setAttribute('x2', 0);
      tempLine.setAttribute('y2', 0);
      polygonPreview.style.display = 'none';
      diagramContainer.classList.remove('hide-hotspots');
      
      markUnsaved();
      updateUI();
      showToast(`Added polygon #${ref}`, 'success');
    }
    
    // Save
    async function saveChanges() {
      if (!currentData || !currentDiagramId) return;
      if (isSaving) return; // prevent re-entrancy
      
      if (autosaveTimer) { clearTimeout(autosaveTimer); autosaveTimer = null; }
      isSaving = true;
      updateSaveStatus('saving');
      
      const sheetText = document.getElementById('currentDiagramInput').value.trim();
      currentData.sheetCode = sheetText ? { text: sheetText, bbox: currentData.sheetCode?.bbox || null } : null;
      
      try {
        const res = await fetch(`${API_BASE}/hotspots/${currentDiagramId}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(currentData),
        });
        if (!res.ok) throw new Error();
        
        hasUnsavedChanges = false;
        updateSaveStatus('saved');
        
        // Update diagram list
        const d = diagrams.find(d => d.id === currentDiagramId);
        if (d) {
          d.hotspotCount = currentData.hotspots.length;
          d.sheetCode = currentData.sheetCode?.text || null;
          d.status = currentData.status;
          renderDiagramList();
        }
      } catch (e) {
        updateSaveStatus('error');
      } finally {
        isSaving = false;
      }
    }
    
    // Mode
    function setMode(mode) {
      currentMode = mode;
      
      // Fully reset polygon/lasso drawing state
      polygonPoints = [];
      isLassoDrawing = false;
      polygonPreview.querySelectorAll('circle').forEach(c => c.remove());
      polygonLines.setAttribute('points', '');
      tempLine.setAttribute('x1', 0);
      tempLine.setAttribute('y1', 0);
      tempLine.setAttribute('x2', 0);
      tempLine.setAttribute('y2', 0);
      closeLine.setAttribute('x1', 0);
      closeLine.setAttribute('y1', 0);
      closeLine.setAttribute('x2', 0);
      closeLine.setAttribute('y2', 0);
      closeLine.style.display = 'none';
      polygonPreview.style.display = 'none';
      polygonPreview.classList.remove('lasso-mode');
      diagramContainer.classList.remove('hide-hotspots');
      
      document.querySelectorAll('.toolbar .mode').forEach(b => {
        b.classList.toggle('active', b.dataset.mode === mode);
      });
      
      diagramContainer.className = 'diagram-container';
      if (mode === 'draw') diagramContainer.classList.add('drawing');
      if (mode === 'isometric') diagramContainer.classList.add('isometric');
      if (mode === 'polygon') diagramContainer.classList.add('polygon');
      if (mode === 'lasso') diagramContainer.classList.add('lasso');
      if (mode === 'wand') diagramContainer.classList.add('wand');
      
      const hints = {
        select: 'Click hotspot to select ‚Ä¢ Drag empty space to pan',
        draw: 'Click and drag to draw rectangle',
        isometric: 'Click and drag to draw diamond/lozenge',
        polygon: 'Click to add points ‚Ä¢ Click first point to close',
        lasso: 'Click and drag to draw freehand shape',
        wand: 'Click on a dark contour line to auto-trace',
      };
      document.getElementById('modeHint').textContent = hints[mode];
      
      if (mode !== 'select') {
        selectedIndex = null;
        updateUI();
      }
    }
    
    // Mouse position relative to image
    function getImagePos(e) {
      const rect = diagramContainer.getBoundingClientRect();
      return {
        x: (e.clientX - rect.left) / zoom,
        y: (e.clientY - rect.top) / zoom,
      };
    }
    
    // Dialog
    let pendingShape = null;
    let editingHotspotIndex = null; // non-null when double-click editing ref
    
    function showRefDialog(shape) {
      pendingShape = shape;
      editingHotspotIndex = null;
      document.getElementById('overlayBg').classList.add('visible');
      document.getElementById('refDialog').classList.add('visible');
      document.querySelector('#refDialog h3').textContent = 'Part Reference Number';
      document.getElementById('confirmRefBtn').textContent = 'Add';
      const input = document.getElementById('refInput');
      input.value = '';
      // Use setTimeout to ensure focus works after DOM update
      setTimeout(() => {
        input.focus();
        input.select();
      }, 50);
    }
    
    function showEditRefDialog(index) {
      const h = currentData.hotspots[index];
      if (!h) return;
      editingHotspotIndex = index;
      pendingShape = null;
      document.getElementById('overlayBg').classList.add('visible');
      document.getElementById('refDialog').classList.add('visible');
      document.querySelector('#refDialog h3').textContent = 'Update Reference Number';
      document.getElementById('confirmRefBtn').textContent = 'Update';
      const input = document.getElementById('refInput');
      input.value = h.ref;
      setTimeout(() => {
        input.focus();
        input.select();
      }, 50);
    }
    
    function closeDialog() {
      document.getElementById('overlayBg').classList.remove('visible');
      document.getElementById('refDialog').classList.remove('visible');
      pendingShape = null;
      editingHotspotIndex = null;
      drawPreview.classList.remove('visible');
      isometricPreview.style.display = 'none';
      
      // Fully reset polygon/lasso drawing state
      polygonPoints = [];
      isLassoDrawing = false;
      polygonPreview.querySelectorAll('circle').forEach(c => c.remove());
      polygonPreview.classList.remove('lasso-mode');
      polygonLines.setAttribute('points', '');
      tempLine.setAttribute('x1', 0);
      tempLine.setAttribute('y1', 0);
      tempLine.setAttribute('x2', 0);
      tempLine.setAttribute('y2', 0);
      closeLine.setAttribute('x1', 0);
      closeLine.setAttribute('y1', 0);
      closeLine.setAttribute('x2', 0);
      closeLine.setAttribute('y2', 0);
      closeLine.style.display = 'none';
      polygonPreview.style.display = 'none';
      
      diagramContainer.classList.remove('hide-hotspots');
      renderHotspots();
    }
    
    function showToast(msg, type = '') {
      const t = document.getElementById('toast');
      t.textContent = msg;
      t.className = 'toast visible ' + type;
      setTimeout(() => t.classList.remove('visible'), 2000);
    }
    
    // Event handlers
    diagramContainer.addEventListener('mousedown', (e) => {
      if (!currentData) return;
      if (e.target.closest('.hotspot-overlay')) return;
      
      const pos = getImagePos(e);
      
      // Middle mouse button or space+click always pans
      if (e.button === 1 || spacePressed) {
        e.preventDefault();
        isPanning = true;
        panStart = { x: e.clientX, y: e.clientY, scrollX: viewport.scrollLeft, scrollY: viewport.scrollTop };
        diagramContainer.classList.add('panning');
        return;
      }
      
      if (currentMode === 'draw' || currentMode === 'isometric') {
        drawStart = pos;
        isDrawing = true;
        diagramContainer.classList.add('hide-hotspots');
      } else if (currentMode === 'lasso') {
        // Start lasso drawing
        isLassoDrawing = true;
        polygonPoints = [pos];
        diagramContainer.classList.add('hide-hotspots');
        polygonPreview.classList.add('lasso-mode');
        updateLassoPreview();
      } else if (currentMode === 'polygon') {
        // Check if clicking near first point to close
        if (polygonPoints.length >= 3) {
          const first = polygonPoints[0];
          const dist = Math.hypot(pos.x - first.x, pos.y - first.y);
          if (dist < 15) {
            showRefDialog({ type: 'polygon', points: [...polygonPoints] });
            return;
          }
        }
        polygonPoints.push(pos);
        diagramContainer.classList.add('hide-hotspots');
        updatePolygonPreview();
      } else if (currentMode === 'wand') {
        handleWandClick(pos);
      } else if (currentMode === 'select') {
        // In select mode, clicking empty space starts panning
        isPanning = true;
        panStart = { x: e.clientX, y: e.clientY, scrollX: viewport.scrollLeft, scrollY: viewport.scrollTop };
        diagramContainer.classList.add('panning');
        selectedIndex = null;
        updateUI();
      }
    });
    
    // Prevent middle-click auto-scroll
    diagramContainer.addEventListener('auxclick', (e) => {
      if (e.button === 1) e.preventDefault();
    });
    
    document.addEventListener('mousemove', (e) => {
      if (!currentData) return;
      
      const pos = getImagePos(e);
      tempMousePos = pos;
      
      if (isPanning && panStart) {
        viewport.scrollLeft = panStart.scrollX - (e.clientX - panStart.x);
        viewport.scrollTop = panStart.scrollY - (e.clientY - panStart.y);
        return;
      }
      
      if (isDrawing && drawStart) {
        if (currentMode === 'isometric') {
          // Draw isometric diamond (30¬∞ angles)
          const width = pos.x - drawStart.x;
          const height = pos.y - drawStart.y;
          const midX = (drawStart.x + pos.x) / 2;
          const midY = (drawStart.y + pos.y) / 2;
          // Isometric uses 30¬∞ angles: vertical extent = horizontal extent * tan(30¬∞) ‚âà 0.577
          const halfWidth = Math.abs(width) / 2;
          const halfHeight = Math.abs(height) / 2;
          const points = [
            `${midX},${midY - halfHeight}`,     // top
            `${midX + halfWidth},${midY}`,      // right
            `${midX},${midY + halfHeight}`,     // bottom
            `${midX - halfWidth},${midY}`,      // left
          ].join(' ');
          isometricPreview.style.display = 'block';
          isometricShape.setAttribute('points', points);
          drawPreview.classList.remove('visible');
        } else {
          const left = Math.min(drawStart.x, pos.x);
          const top = Math.min(drawStart.y, pos.y);
          const width = Math.abs(pos.x - drawStart.x);
          const height = Math.abs(pos.y - drawStart.y);
          drawPreview.style.cssText = `left:${left}px;top:${top}px;width:${width}px;height:${height}px;`;
          drawPreview.classList.add('visible');
          isometricPreview.style.display = 'none';
        }
      }
      
      if (currentMode === 'polygon' && polygonPoints.length > 0) {
        updatePolygonPreview();
      }
      
      // Lasso: capture points while dragging
      if (isLassoDrawing && polygonPoints.length > 0) {
        const lastPoint = polygonPoints[polygonPoints.length - 1];
        const dist = Math.hypot(pos.x - lastPoint.x, pos.y - lastPoint.y);
        if (dist >= LASSO_MIN_DISTANCE) {
          polygonPoints.push(pos);
          updateLassoPreview();
        }
      }
      
      if (isMoving && moveStart && selectedIndex !== null) {
        const dx = (e.clientX - moveStart.x) / zoom;
        const dy = (e.clientY - moveStart.y) / zoom;
        const h = currentData.hotspots[selectedIndex];
        
        if (h.type === 'polygon' && originalPoints) {
          h.points = originalPoints.map(p => ({ x: p.x + dx, y: p.y + dy }));
        } else if (originalBbox) {
          h.bbox.x = Math.max(0, originalBbox.x + dx);
          h.bbox.y = Math.max(0, originalBbox.y + dy);
        }
        renderHotspots();
      }
      
      if (vertexIndex !== null && moveStart && selectedIndex !== null) {
        const dx = (e.clientX - moveStart.x) / zoom;
        const dy = (e.clientY - moveStart.y) / zoom;
        const h = currentData.hotspots[selectedIndex];
        if (h.type === 'polygon' && originalPoints) {
          h.points[vertexIndex] = {
            x: originalPoints[vertexIndex].x + dx,
            y: originalPoints[vertexIndex].y + dy,
          };
          renderHotspots();
        }
      }
      
      if (isResizing && moveStart && selectedIndex !== null) {
        const dx = (e.clientX - moveStart.x) / zoom;
        const dy = (e.clientY - moveStart.y) / zoom;
        const h = currentData.hotspots[selectedIndex];
        const min = 10;
        
        if (resizeHandle.includes('w')) {
          const newX = Math.min(originalBbox.x + originalBbox.width - min, originalBbox.x + dx);
          h.bbox.width = originalBbox.width - (newX - originalBbox.x);
          h.bbox.x = newX;
        }
        if (resizeHandle.includes('e')) h.bbox.width = Math.max(min, originalBbox.width + dx);
        if (resizeHandle.includes('n')) {
          const newY = Math.min(originalBbox.y + originalBbox.height - min, originalBbox.y + dy);
          h.bbox.height = originalBbox.height - (newY - originalBbox.y);
          h.bbox.y = newY;
        }
        if (resizeHandle.includes('s')) h.bbox.height = Math.max(min, originalBbox.height + dy);
        
        renderHotspots();
      }
    });
    
    document.addEventListener('mouseup', (e) => {
      if (isPanning) {
        isPanning = false;
        panStart = null;
        diagramContainer.classList.remove('panning');
        return;
      }
      
      // Finish lasso drawing
      if (isLassoDrawing) {
        isLassoDrawing = false;
        if (polygonPoints.length >= 3) {
          // Simplify the polygon to reduce point count
          const simplified = simplifyPolygon(polygonPoints, 3);
          if (simplified.length >= 3) {
            showRefDialog({ type: 'polygon', points: simplified });
          } else {
            // Not enough points after simplification
            resetLassoState();
          }
        } else {
          // Not enough points
          resetLassoState();
        }
        return;
      }
      
      if (isDrawing && drawStart) {
        const pos = getImagePos(e);
        const width = Math.abs(pos.x - drawStart.x);
        const height = Math.abs(pos.y - drawStart.y);
        
        if (width > 10 && height > 10) {
          if (currentMode === 'isometric') {
            // Create isometric diamond polygon (30¬∞ angles)
            const midX = (drawStart.x + pos.x) / 2;
            const midY = (drawStart.y + pos.y) / 2;
            const halfWidth = width / 2;
            const halfHeight = height / 2;
            const points = [
              { x: midX, y: midY - halfHeight },  // top
              { x: midX + halfWidth, y: midY },   // right
              { x: midX, y: midY + halfHeight },  // bottom
              { x: midX - halfWidth, y: midY },   // left
            ];
            showRefDialog({ type: 'polygon', points });
          } else {
            const left = Math.min(drawStart.x, pos.x);
            const top = Math.min(drawStart.y, pos.y);
            showRefDialog({ type: 'rect', bbox: { x: left, y: top, width, height } });
          }
        } else {
          drawPreview.classList.remove('visible');
          isometricPreview.style.display = 'none';
          diagramContainer.classList.remove('hide-hotspots');
        }
        isDrawing = false;
        drawStart = null;
      }
      
      // Check for vertex click-to-delete (minimal movement = click, not drag)
      if (vertexClickStart && vertexIndex !== null) {
        const dist = Math.hypot(e.clientX - vertexClickStart.x, e.clientY - vertexClickStart.y);
        const h = currentData.hotspots[vertexClickStart.hotspotIndex];
        if (dist < 5 && h && h.type === 'polygon' && h.points.length > 3) {
          // Delete vertex on click
          h.points.splice(vertexIndex, 1);
          vertexIndex = null;
          markUnsaved();
          renderHotspots();
          vertexClickStart = null;
          return;
        }
      }
      
      if ((isMoving || isResizing || vertexIndex !== null) && selectedIndex !== null) {
        markUnsaved();
        updateEditPanel();
      }
      
      isMoving = false;
      isResizing = false;
      vertexIndex = null;
      vertexClickStart = null;
      resizeHandle = null;
      moveStart = null;
      originalBbox = null;
      originalPoints = null;
      diagramContainer.classList.remove('moving');
    });
    
    function updatePolygonPreview() {
      // Clear existing circles first
      polygonPreview.querySelectorAll('circle').forEach(c => c.remove());
      
      if (polygonPoints.length === 0) {
        polygonPreview.style.display = 'none';
        polygonLines.setAttribute('points', '');
        tempLine.setAttribute('x1', 0);
        tempLine.setAttribute('y1', 0);
        tempLine.setAttribute('x2', 0);
        tempLine.setAttribute('y2', 0);
        return;
      }
      
      polygonPreview.style.display = 'block';
      polygonLines.setAttribute('points', polygonPoints.map(p => `${p.x},${p.y}`).join(' '));
      
      if (tempMousePos && polygonPoints.length > 0) {
        const last = polygonPoints[polygonPoints.length - 1];
        tempLine.setAttribute('x1', last.x);
        tempLine.setAttribute('y1', last.y);
        tempLine.setAttribute('x2', tempMousePos.x);
        tempLine.setAttribute('y2', tempMousePos.y);
      }
      
      // Add circles for each point
      polygonPoints.forEach((p, i) => {
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', p.x);
        circle.setAttribute('cy', p.y);
        circle.setAttribute('r', i === 0 && polygonPoints.length >= 3 ? '8' : '5');
        if (i === 0 && polygonPoints.length >= 3) circle.classList.add('close-hint');
        polygonPreview.appendChild(circle);
      });
    }
    
    function updateLassoPreview() {
      if (polygonPoints.length === 0) {
        polygonPreview.style.display = 'none';
        return;
      }
      
      polygonPreview.style.display = 'block';
      polygonLines.setAttribute('points', polygonPoints.map(p => `${p.x},${p.y}`).join(' '));
      
      // Show closing line from last point back to first
      if (polygonPoints.length >= 2) {
        const first = polygonPoints[0];
        const last = polygonPoints[polygonPoints.length - 1];
        closeLine.setAttribute('x1', last.x);
        closeLine.setAttribute('y1', last.y);
        closeLine.setAttribute('x2', first.x);
        closeLine.setAttribute('y2', first.y);
        closeLine.style.display = 'block';
      }
    }
    
    function resetLassoState() {
      polygonPoints = [];
      isLassoDrawing = false;
      polygonPreview.classList.remove('lasso-mode');
      polygonLines.setAttribute('points', '');
      closeLine.style.display = 'none';
      closeLine.setAttribute('x1', 0);
      closeLine.setAttribute('y1', 0);
      closeLine.setAttribute('x2', 0);
      closeLine.setAttribute('y2', 0);
      polygonPreview.style.display = 'none';
      diagramContainer.classList.remove('hide-hotspots');
    }
    
    // Douglas-Peucker polygon simplification
    function simplifyPolygon(points, tolerance) {
      if (points.length <= 2) return points;
      
      // Find the point with the maximum distance from line between first and last
      let maxDist = 0;
      let maxIndex = 0;
      const first = points[0];
      const last = points[points.length - 1];
      
      for (let i = 1; i < points.length - 1; i++) {
        const dist = perpendicularDistance(points[i], first, last);
        if (dist > maxDist) {
          maxDist = dist;
          maxIndex = i;
        }
      }
      
      // If max distance is greater than tolerance, recursively simplify
      if (maxDist > tolerance) {
        const left = simplifyPolygon(points.slice(0, maxIndex + 1), tolerance);
        const right = simplifyPolygon(points.slice(maxIndex), tolerance);
        return left.slice(0, -1).concat(right);
      } else {
        return [first, last];
      }
    }
    
    function perpendicularDistance(point, lineStart, lineEnd) {
      const dx = lineEnd.x - lineStart.x;
      const dy = lineEnd.y - lineStart.y;
      const lineLengthSq = dx * dx + dy * dy;
      
      if (lineLengthSq === 0) {
        return Math.hypot(point.x - lineStart.x, point.y - lineStart.y);
      }
      
      const t = Math.max(0, Math.min(1, 
        ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / lineLengthSq
      ));
      
      const projX = lineStart.x + t * dx;
      const projY = lineStart.y + t * dy;
      
      return Math.hypot(point.x - projX, point.y - projY);
    }
    
    // ‚îÄ‚îÄ Magic Wand algorithm ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    
    function ensureWandData() {
      if (wandImageData) return wandImageData;
      if (!wandCanvas) {
        wandCanvas = document.createElement('canvas');
        wandCtx = wandCanvas.getContext('2d', { willReadFrequently: true });
      }
      wandCanvas.width = currentData.imageWidth;
      wandCanvas.height = currentData.imageHeight;
      wandCtx.drawImage(diagramImage, 0, 0);
      wandImageData = wandCtx.getImageData(0, 0, wandCanvas.width, wandCanvas.height);
      return wandImageData;
    }
    
    function getPixelBrightness(imgData, x, y) {
      const i = (y * imgData.width + x) * 4;
      return (imgData.data[i] + imgData.data[i + 1] + imgData.data[i + 2]) / 3;
    }
    
    // Snap click to nearest dark pixel within radius
    function findNearestDarkPixel(imgData, sx, sy, radius) {
      const w = imgData.width, h = imgData.height;
      const x = Math.round(sx), y = Math.round(sy);
      
      if (x >= 0 && x < w && y >= 0 && y < h &&
          getPixelBrightness(imgData, x, y) < WAND_THRESHOLD) {
        return { x, y };
      }
      
      let bestDist = Infinity, best = null;
      for (let dy = -radius; dy <= radius; dy++) {
        for (let dx = -radius; dx <= radius; dx++) {
          const nx = x + dx, ny = y + dy;
          if (nx < 0 || nx >= w || ny < 0 || ny >= h) continue;
          const d2 = dx * dx + dy * dy;
          if (d2 >= bestDist) continue;
          if (getPixelBrightness(imgData, nx, ny) < WAND_THRESHOLD) {
            bestDist = d2;
            best = { x: nx, y: ny };
          }
        }
      }
      return best;
    }
    
    // BFS flood fill of connected dark pixels (8-connected)
    function wandFloodFill(startX, startY, imgData) {
      const w = imgData.width, h = imgData.height;
      
      const mask = new Uint8Array(w * h);
      const queue = new Int32Array(Math.min(WAND_MAX_PIXELS * 2, w * h));
      let qHead = 0, qTail = 0;
      
      const idx = startY * w + startX;
      mask[idx] = 1;
      queue[qTail++] = idx;
      let count = 0;
      let minX = startX, maxX = startX, minY = startY, maxY = startY;
      
      while (qHead < qTail && count < WAND_MAX_PIXELS) {
        const ci = queue[qHead++];
        const cx = ci % w;
        const cy = (ci - cx) / w;
        count++;
        
        if (cx < minX) minX = cx;
        if (cx > maxX) maxX = cx;
        if (cy < minY) minY = cy;
        if (cy > maxY) maxY = cy;
        
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue;
            const nx = cx + dx, ny = cy + dy;
            if (nx < 0 || nx >= w || ny < 0 || ny >= h) continue;
            const ni = ny * w + nx;
            if (mask[ni]) continue;
            if (getPixelBrightness(imgData, nx, ny) < WAND_THRESHOLD) {
              mask[ni] = 1;
              if (qTail < queue.length) queue[qTail++] = ni;
            }
          }
        }
      }
      
      if (count < WAND_MIN_PIXELS) return null;
      return { mask, width: w, height: h, count, bounds: { minX, maxX, minY, maxY } };
    }
    
    // Morphological dilation ‚Äî thickens thin lines into proper 2D bands
    function dilateMask(mask, w, h, radius, bounds) {
      const result = new Uint8Array(w * h);
      const r2 = radius * radius;
      const { minX, maxX, minY, maxY } = bounds;
      
      for (let y = minY; y <= maxY; y++) {
        for (let x = minX; x <= maxX; x++) {
          if (!mask[y * w + x]) continue;
          for (let dy = -radius; dy <= radius; dy++) {
            const ny = y + dy;
            if (ny < 0 || ny >= h) continue;
            for (let dx = -radius; dx <= radius; dx++) {
              if (dx * dx + dy * dy > r2) continue;
              const nx = x + dx;
              if (nx < 0 || nx >= w) continue;
              result[ny * w + nx] = 1;
            }
          }
        }
      }
      
      return {
        mask: result,
        bounds: {
          minX: Math.max(0, minX - radius),
          maxX: Math.min(w - 1, maxX + radius),
          minY: Math.max(0, minY - radius),
          maxY: Math.min(h - 1, maxY + radius),
        }
      };
    }
    
    // Convert flood-filled mask to polygon: dilate ‚Üí boundary ‚Üí radial sample
    function wandMaskToPolygon(result, expandRadius) {
      const { mask, width: w, height: h, bounds } = result;
      
      // Dilate mask so thin lines become proper 2D bands
      const dilated = dilateMask(mask, w, h, expandRadius, bounds);
      const dmask = dilated.mask;
      const db = dilated.bounds;
      
      // Find boundary pixels and centroid of dilated mask
      const boundary = [];
      let sumX = 0, sumY = 0, totalCount = 0;
      
      for (let y = db.minY; y <= db.maxY; y++) {
        for (let x = db.minX; x <= db.maxX; x++) {
          if (!dmask[y * w + x]) continue;
          sumX += x;
          sumY += y;
          totalCount++;
          
          if (x === 0 || !dmask[y * w + (x - 1)] ||
              x === w - 1 || !dmask[y * w + (x + 1)] ||
              y === 0 || !dmask[(y - 1) * w + x] ||
              y === h - 1 || !dmask[(y + 1) * w + x]) {
            boundary.push({ x, y });
          }
        }
      }
      
      if (boundary.length < 3) return null;
      
      const cx = sumX / totalCount;
      const cy = sumY / totalCount;
      
      // Angular bucket sort: keep outermost boundary pixel per angular slice
      const angleStep = (2 * Math.PI) / WAND_BUCKETS;
      const buckets = new Array(WAND_BUCKETS).fill(null);
      
      for (const p of boundary) {
        const angle = Math.atan2(p.y - cy, p.x - cx);
        const norm = ((angle % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
        const bi = Math.floor(norm / angleStep) % WAND_BUCKETS;
        const dist = Math.hypot(p.x - cx, p.y - cy);
        
        if (!buckets[bi] || dist > buckets[bi].dist) {
          buckets[bi] = { x: p.x, y: p.y, dist };
        }
      }
      
      // Collect non-null buckets (no extra expansion ‚Äî dilation already did it)
      const polygon = [];
      for (let i = 0; i < WAND_BUCKETS; i++) {
        const b = buckets[i];
        if (!b) continue;
        polygon.push({ x: Math.round(b.x), y: Math.round(b.y) });
      }
      
      return polygon.length >= 3 ? polygon : null;
    }
    
    function handleWandClick(pos) {
      const imgData = ensureWandData();
      
      // Snap to nearest dark pixel (forgiving click)
      const seed = findNearestDarkPixel(imgData, pos.x, pos.y, WAND_SNAP_RADIUS);
      if (!seed) {
        showToast('No dark contour found nearby', 'error');
        return;
      }
      
      const result = wandFloodFill(seed.x, seed.y, imgData);
      if (!result) {
        showToast('Region too small to trace', 'error');
        return;
      }
      
      if (result.count >= WAND_MAX_PIXELS) {
        showToast('Region too large ‚Äî try a smaller outline', 'error');
        return;
      }
      
      const polygon = wandMaskToPolygon(result, WAND_EXPAND);
      if (!polygon) {
        showToast('Could not trace contour', 'error');
        return;
      }
      
      // Simplify to clean polygon
      const simplified = simplifyPolygon(polygon, 3);
      if (simplified.length < 3) {
        showToast('Shape too small to trace', 'error');
        return;
      }
      
      showRefDialog({ type: 'polygon', points: simplified });
    }
    
    // Zoom wheel - gentler zoom speed
    viewport.addEventListener('wheel', (e) => {
      if (!currentData) return;
      e.preventDefault();
      const delta = e.deltaY > 0 ? 0.95 : 1.05;
      setZoom(zoom * delta, e.clientX, e.clientY);
    }, { passive: false });
    
    // Keyboard
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space' && !e.target.matches('input')) {
        e.preventDefault();
        spacePressed = true;
        if (currentData) diagramContainer.classList.add('panning');
      }
      
      if (e.key === 's' && (e.ctrlKey || e.metaKey)) {
        e.preventDefault();
        saveChanges();
      }
      
      if (e.key === 'd' && (e.ctrlKey || e.metaKey) && !e.target.matches('input')) {
        e.preventDefault();
        if (selectedIndex !== null) duplicateHotspot(selectedIndex);
      }
      
      if (e.key === 'Escape') {
        if (pendingShape) {
          closeDialog();
        } else if (isLassoDrawing || (currentMode === 'lasso' && polygonPoints.length > 0)) {
          resetLassoState();
        } else if (polygonPoints.length > 0) {
          polygonPoints = [];
          diagramContainer.classList.remove('hide-hotspots');
          updatePolygonPreview();
        } else if (selectedIndex !== null) {
          selectedIndex = null;
          updateUI();
        } else if (currentMode !== 'select') {
          // ESC with nothing selected reverts to Select mode
          setMode('select');
        }
      }
      
      if ((e.key === 'Delete' || e.key === 'Backspace') && selectedIndex !== null && !e.target.matches('input')) {
        e.preventDefault();
        deleteHotspot(selectedIndex);
      }
      
      // Tool shortcuts (only when not typing in input)
      if (!e.target.matches('input') && !e.ctrlKey && !e.metaKey) {
        if (e.key === 'v' || e.key === 'V') {
          e.preventDefault();
          setMode('select');
        } else if (e.key === 'r' || e.key === 'R') {
          e.preventDefault();
          setMode('draw');
        } else if (e.key === 'l' || e.key === 'L') {
          e.preventDefault();
          setMode('polygon');
        } else if (e.key === 'i' || e.key === 'I') {
          e.preventDefault();
          setMode('isometric');
        } else if (e.key === 'o' || e.key === 'O') {
          e.preventDefault();
          setMode('lasso');
        } else if (e.key === 'w' || e.key === 'W') {
          e.preventDefault();
          setMode('wand');
        }
      }
    });
    
    document.addEventListener('keyup', (e) => {
      if (e.code === 'Space') {
        spacePressed = false;
        if (currentData && !isPanning) diagramContainer.classList.remove('panning');
      }
    });
    
    // UI event bindings
    document.querySelectorAll('.toolbar .mode').forEach(btn => {
      btn.addEventListener('click', () => setMode(btn.dataset.mode));
    });
    
    document.querySelectorAll('.filter-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        currentFilter = btn.dataset.filter;
        document.querySelectorAll('.filter-btn').forEach(b => b.classList.toggle('active', b === btn));
        renderDiagramList();
      });
    });
    
    document.querySelectorAll('.status-toggle .status-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        if (!currentData) return;
        currentData.status = btn.dataset.status;
        markUnsaved();
        updateStatusButtons();
      });
    });
    
    document.getElementById('confirmRefBtn').addEventListener('click', () => {
      const ref = parseInt(document.getElementById('refInput').value);
      if (ref >= 1 && ref <= 99) {
        if (editingHotspotIndex !== null) {
          currentData.hotspots[editingHotspotIndex].ref = ref;
          markUnsaved();
          updateUI();
        } else if (pendingShape) {
          if (pendingShape.type === 'rect') addRectHotspot(pendingShape.bbox, ref);
          else if (pendingShape.type === 'polygon') addPolygonHotspot(pendingShape.points, ref);
        }
      }
      closeDialog();
    });
    
    document.getElementById('cancelRefBtn').addEventListener('click', closeDialog);
    document.getElementById('overlayBg').addEventListener('click', closeDialog);
    
    document.getElementById('refInput').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') document.getElementById('confirmRefBtn').click();
      else if (e.key === 'Escape') closeDialog();
    });
    
    document.getElementById('currentDiagramInput').addEventListener('input', markUnsaved);
    document.getElementById('clearAllBtn').addEventListener('click', () => {
      if (!confirm('Clear all hotspots?')) return;
      currentData.hotspots = [];
      selectedIndex = null;
      markUnsaved();
      updateUI();
    });
    
    document.getElementById('diagramSearch').addEventListener('input', renderDiagramList);
    
    document.getElementById('applyEditBtn').addEventListener('click', () => {
      if (selectedIndex === null) return;
      currentData.hotspots[selectedIndex].ref = parseInt(document.getElementById('editRef').value) || 1;
      markUnsaved();
      updateUI();
    });
    
    document.getElementById('deleteSelectedBtn').addEventListener('click', () => {
      if (selectedIndex !== null) deleteHotspot(selectedIndex);
    });
    
    document.getElementById('editRef').addEventListener('change', () => {
      document.getElementById('applyEditBtn').click();
    });
    
    document.getElementById('zoomIn').addEventListener('click', () => setZoom(zoom * 1.25));
    document.getElementById('zoomOut').addEventListener('click', () => setZoom(zoom / 1.25));
    document.getElementById('zoomFit').addEventListener('click', fitToView);
    
    window.addEventListener('resize', () => {
      if (currentData) renderHotspots();
    });
    
    window.addEventListener('beforeunload', () => {
      // Fire-and-forget save on page close
      if (hasUnsavedChanges && currentData && currentDiagramId) {
        const sheetText = document.getElementById('currentDiagramInput').value.trim();
        currentData.sheetCode = sheetText ? { text: sheetText, bbox: currentData.sheetCode?.bbox || null } : null;
        navigator.sendBeacon(
          `${API_BASE}/hotspots/${currentDiagramId}`,
          new Blob([JSON.stringify(currentData)], { type: 'application/json' })
        );
      }
    });
    
    // Init
    loadDiagramList();
    setInterval(() => { if (!isConnected) loadDiagramList(); }, 3000);
  </script>
</body>
</html>
